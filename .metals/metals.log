2021.01.05 18:16:36 INFO  Started: Metals version 0.9.8 in workspace '/Users/stan/Dev/cv' for client vscode.
2021.01.05 18:16:47 INFO  time: initialize in 10s
2021.01.05 18:16:59 WARN  Build server is not auto-connectable.
2021.01.05 18:16:59 WARN  no build tool detected in workspace '/Users/stan/Dev/cv'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. 
Jan 06, 2021 11:28:18 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 11, 2021 9:15:50 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 1:56:58 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:00:06 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:00:29 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:00:30 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:00:39 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:00:49 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:00:49 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:00:49 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:00:49 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:01:12 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:01:28 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:01:39 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:01:41 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:01:43 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 14, 2021 2:01:43 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 2:06:44 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:16:23 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:16:38 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:44:59 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:45:05 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:45:11 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:45:19 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:45:27 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:45:32 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:45:39 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:45:50 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:45:58 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:46:05 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:46:14 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:46:44 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:46:48 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:48:33 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:48:43 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:48:51 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:48:59 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:49:03 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:49:10 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:49:26 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:51:18 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:51:22 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Jan 21, 2021 5:51:38 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
2021.01.23 02:19:56 INFO  shutting down Metals
[0m2021.01.31 04:26:01 INFO  Started: Metals version 0.9.10 in workspace '/Users/stan/Dev/cv' for client vscode 1.52.1.[0m
[0m2021.01.31 04:26:12 INFO  time: initialize in 11s[0m
[0m2021.01.31 04:26:15 WARN  resetting database: /Users/stan/Dev/cv/.metals/metals.h2.db[0m
[0m2021.01.31 04:26:16 WARN  Build server is not auto-connectable.[0m
[0m2021.01.31 04:26:16 WARN  no build tool detected in workspace '/Users/stan/Dev/cv'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. [0m
[0m2021.02.04 03:14:40 INFO  shutting down Metals[0m
[0m2021.02.23 03:55:45 INFO  Started: Metals version 0.9.10 in workspace '/Users/stan/Dev/cv' for client vscode 1.53.2.[0m
[0m2021.02.23 03:56:00 INFO  time: initialize in 14s[0m
[0m2021.02.23 03:56:04 WARN  Build server is not auto-connectable.[0m
[0m2021.02.23 03:56:04 WARN  no build tool detected in workspace '/Users/stan/Dev/cv'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. [0m
Feb 23, 2021 4:07:57 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Feb 23, 2021 4:07:58 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Feb 23, 2021 4:08:03 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Feb 23, 2021 4:08:08 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Feb 23, 2021 4:08:10 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Feb 23, 2021 4:08:10 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
[0m2021.02.23 04:09:46 INFO  shutting down Metals[0m
[0m2021.03.23 14:51:02 INFO  Started: Metals version 0.10.0 in workspace '/Users/stan/Dev/cv' for client vscode 1.54.3.[0m
[0m2021.03.23 14:51:04 INFO  time: initialize in 1.99s[0m
[0m2021.03.23 14:51:04 WARN  Build server is not auto-connectable.[0m
[0m2021.03.23 14:51:04 WARN  no build tool detected in workspace '/Users/stan/Dev/cv'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. [0m
[0m2021.03.23 14:51:04 WARN  no build target for: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/search/SearchFlow.scala[0m
[0m2021.03.23 14:51:08 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
<<<<<<< HEAD
              case dialog: UserDialog.Private =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(dialog.lastClearPeerMsgId, cmd.minId) else dialog.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, cmd.maxId) else dialog.maxPeerMsgId
                dialogMessagesRepo
                  .search(
                    dialogId = dialog.dialogId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        dialog.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
=======
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:51:10 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3054)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
<<<<<<< HEAD
              case dialog: UserDialog.Private =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(dialog.lastClearPeerMsgId, cmd.minId) else dialog.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, cmd.maxId) else dialog.maxPeerMsgId
                dialogMessagesRepo
                  .search(
                    dialogId = dialog.dialogId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        dialog.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
=======
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:51:10 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3054)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
<<<<<<< HEAD
              case dialog: UserDialog.Private =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(dialog.lastClearPeerMsgId, cmd.minId) else dialog.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, cmd.maxId) else dialog.maxPeerMsgId
                dialogMessagesRepo
                  .search(
                    dialogId = dialog.dialogId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        dialog.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
=======
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:51:10 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3054)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.23 14:51:11 INFO  time: code lens generation in 6s[0m
package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
<<<<<<< HEAD
              case dialog: UserDialog.Private =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(dialog.lastClearPeerMsgId, cmd.minId) else dialog.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, cmd.maxId) else dialog.maxPeerMsgId
                dialogMessagesRepo
                  .search(
                    dialogId = dialog.dialogId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        dialog.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
=======
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:51:11 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3054)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.23 14:51:11 INFO  time: code lens generation in 6.25s[0m
package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
<<<<<<< HEAD
              case dialog: UserDialog.Private =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(dialog.lastClearPeerMsgId, cmd.minId) else dialog.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, cmd.maxId) else dialog.maxPeerMsgId
                dialogMessagesRepo
                  .search(
                    dialogId = dialog.dialogId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        dialog.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
=======
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:51:12 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3054)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
<<<<<<< HEAD
              case dialog: UserDialog.Private =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(dialog.lastClearPeerMsgId, cmd.minId) else dialog.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, cmd.maxId) else dialog.maxPeerMsgId
                dialogMessagesRepo
                  .search(
                    dialogId = dialog.dialogId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        dialog.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
=======
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:51:14 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3054)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
<<<<<<< HEAD
              case dialog: UserDialog.Private =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(dialog.lastClearPeerMsgId, cmd.minId) else dialog.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, cmd.maxId) else dialog.maxPeerMsgId
                dialogMessagesRepo
                  .search(
                    dialogId = dialog.dialogId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        dialog.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
=======
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:51:14 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:47: error: case expected but identifier found
<<<<<<< HEAD
^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3054)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.23 14:51:15 WARN  no build target for: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/search/SearchFlow.scala[0m
package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:51:15 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:51:18 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:51:18 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.23 14:51:18 WARN  no build target for: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/dialogs/DialogMessagesRepo.scala[0m
Mar 23, 2021 2:51:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16
package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:19 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:19 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:20 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.23 14:51:20 INFO  time: code lens generation in 1.66s[0m
package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:20 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.23 14:51:20 INFO  time: code lens generation in 1.99s[0m
package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:25 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:27 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:27 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:33 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:34 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:34 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:38 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:39 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:39 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
<<<<<<< HEAD
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
=======
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

<<<<<<< HEAD
=======
  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

<<<<<<< HEAD
=======
  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

Mar 23, 2021 2:51:39 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fdialogs%2FDialogMessagesRepo.scala:439: error: identifier expected but ) found
>>>>>>> ad490e34 (chore: fix Last Filter in Dialog Search)
                                                         ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$simpleType$1(ScalametaParser.scala:1688)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType(ScalametaParser.scala:1672)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.simpleType$(ScalametaParser.scala:1671)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.simpleType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.annotType$(ScalametaParser.scala:1663)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.annotType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType(ScalametaParser.scala:1643)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.compoundType$(ScalametaParser.scala:1639)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.compoundType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$infixTypeRest$1(ScalametaParser.scala:1629)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest(ScalametaParser.scala:1603)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeRest$(ScalametaParser.scala:1602)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeRest(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType(ScalametaParser.scala:1600)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixType$(ScalametaParser.scala:1599)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixType(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple(ScalametaParser.scala:1596)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.infixTypeOrTuple$(ScalametaParser.scala:1594)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.infixTypeOrTuple(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.$anonfun$typ$1(ScalametaParser.scala:1543)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$PatternContextSensitive.typ$(ScalametaParser.scala:1540)
	at scala.meta.internal.parsers.ScalametaParser$outPattern$.typ(ScalametaParser.scala:3384)
	at scala.meta.internal.parsers.ScalametaParser.typ(ScalametaParser.scala:3406)
	at scala.meta.internal.parsers.ScalametaParser.typeOrInfixType(ScalametaParser.scala:2080)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$21(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2332)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprs(ScalametaParser.scala:2971)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2934)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$classDef$1(ScalametaParser.scala:4377)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.classDef(ScalametaParser.scala:4353)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4309)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.23 14:51:42 WARN  no build target for: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/dialogs/DialogMessagesRepo.scala[0m
package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false"
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

package im.chat
package services
package dialogs

import scala.collection.mutable

import cats.implicits._
import com.github.plokhotnyuk.fsi._
import doobie._
import doobie.implicits._
import doobie.util.fragment.Elem
import zio.IO

import im.chat.common.MessagesPeer
import im.chat.persist.postgres.Implicits._
import im.chat.persist.postgres.{SqlHelpers, TlImplicits}
import im.chat.services.messages._
import im.chat.tl.schema.{MessageEntity => TlMessageEntity, Update => _, _}
import im.chat.utils.Random

sealed trait DialogMessageRef
object DialogMessageRef {
  final case class Id(dialogId: Long, messageId: Int) extends DialogMessageRef
  final case class Random(dialogId: Long, randomId: Long, userId: Int) extends DialogMessageRef
}

final case class DialogMessageEntity(
    id: Int,
    val peer: MessagesPeer.Dialog,
    userId: Int,
    randomId: Long,
    message: Option[String],
    media: Option[MessageMedia],
    action: Option[MessageAction],
    kind: MessageKind,
    groupedId: Option[Long],
    replyToId: Option[Int],
    fwdFrom: Option[MessageFwdHeader],
    replyMarkup: Option[ReplyMarkup],
    entities: collection.Seq[TlMessageEntity],
    date: Int,
    editDate: Option[Int],
    viaBotId: Option[Int],
    views: Int,
    flags: Short,
    deleted: Boolean
) extends ConversationMessageEntity {
  override def post: Boolean = false
  override def silent: Boolean = false
  override def fromId = Some(this.userId)
  override def postAuthor: Option[String] = None
  override def getFwdHeader =
    this.fwdFrom.getOrElse(
      MessageFwdHeader(
        fromId = Some(this.userId),
        fromName = None,
        date = this.date,
        channelId = None,
        channelPost = None,
        postAuthor = None,
        savedFromPeer = None,
        savedFromMsgId = None
      )
    )

  def refKey(userId: Int): MessageEntity.RefKey = MessageEntity.refKey(peerId = peer.getParticipantId(userId), id = id)

  def toIdRef: DialogMessageRef.Id = DialogMessageRef.Id(dialogId = this.peer.id, messageId = this.id)

  def toRandomRef: DialogMessageRef.Random =
    DialogMessageRef.Random(dialogId = this.peer.id, userId = this.userId, randomId = this.randomId)
}
object DialogMessageEntity {
  def apply(
      id: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      action: MessageAction,
      date: Int
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      media = None,
      action = Some(action),
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = None,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = None,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      randomId: Long,
      message: String,
      fwdFrom: Option[MessageFwdHeader],
      replyToId: Option[Int],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      media: Option[MessageMedia],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity = {
    val kind = MessageKind.from(message, media)
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = randomId,
      message = Some(message),
      media = media,
      action = None,
      kind = kind,
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = fwdFrom,
      replyMarkup = replyMarkup,
      entities = entities,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = MessageEntity.Flags(viaBot = false, kind, media),
      deleted = false
    )
  }

  // TODO: replace it by single method
  def apply(
      id: Int,
      peer: MessagesPeer.Dialog,
      userId: Int,
      action: MessageAction,
      replyToId: Option[Int],
      date: Int,
      viaBotId: Option[Int]
  ): DialogMessageEntity =
    DialogMessageEntity(
      id = id,
      userId = userId,
      peer = peer,
      randomId = 0L,
      message = None,
      action = Some(action),
      media = None,
      kind = MessageKind.from(action),
      groupedId = None,
      replyToId = replyToId,
      fwdFrom = None,
      replyMarkup = None,
      entities = Nil,
      date = date,
      editDate = None,
      viaBotId = viaBotId,
      views = 0,
      flags = 0,
      deleted = false
    )

  def apply(
      lastId: Int,
      userId: Int,
      peer: MessagesPeer.Dialog,
      replyToId: Option[Int],
      groupedId: Option[Long],
      messages: collection.Seq[NewMessageRequest],
      date: Int,
      viaBotId: Option[Int]
  ): collection.Seq[DialogMessageEntity] = {
    val count = messages.length
    val buf = new mutable.ArrayBuffer[DialogMessageEntity](count)

    var _id: Int = lastId - count
    messages.foreach { req =>
      _id += 1

      val kind = MessageKind.from(req.text, req.media)
      buf += DialogMessageEntity(
        id = _id,
        userId = userId,
        peer = peer,
        randomId = req.randomId,
        message = Some(req.text),
        action = None,
        media = req.media,
        kind = kind,
        groupedId = groupedId,
        replyToId = replyToId,
        fwdFrom = req.fwdFrom,
        replyMarkup = None,
        entities = req.entities,
        date = date,
        editDate = None,
        viaBotId = viaBotId,
        views = req.views,
        flags = MessageEntity.Flags(viaBot = false, kind, req.media),
        deleted = false
      )
    }
    buf
  }

  def update(
      userId: Int,
      bot: Boolean,
      entity: DialogMessageEntity,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: Option[collection.Seq[TlMessageEntity]],
      stopGeoLive: Boolean,
      geoPoint: Option[InputGeoPoint],
      date: Int,
      editIntervalSeconds: Int
  ): Either[ServiceError, DialogMessageEntity] =
    if (entity.userId != userId || entity.deleted) ServiceErrors.MessageIdInvalid.left
    else if (!bot && entity.isExpired(date = date, editInterval = editIntervalSeconds))
      ServiceErrors.MessageEditTimeExpired.left
    else
      entity.media match {
        case Some(oldMedia: MessageMediaGeoLive) =>
          if (entity.date + oldMedia.period < date) ServiceErrors.MessageEditTimeExpired.left
          else
            geoPoint match {
              case Some(point: InputGeoPointItem) =>
                val geo = GeoPointItem(long = point.long, lat = point.lat, accessHash = Random.accessHash())
                Right(entity.copy(media = Some(oldMedia.copy(geo = geo))))
              case _ =>
                if (stopGeoLive)
                  Right(entity.copy(media = Some(oldMedia.copy(period = date - entity.date))))
                else ServiceErrors.MessageNotModified.left
            }
        case _ =>
          if (
            (message.isEmpty || message == entity.message) && (media.isEmpty || media == entity.media) &&
            (replyMarkup.isEmpty || replyMarkup == entity.replyMarkup) && (entities.isEmpty || entities.contains(entity.entities))
          )
            ServiceErrors.MessageNotModified.left
          else
            Right(
              entity.copy(
                message = message.orElse(entity.message),
                media = media.orElse(entity.media),
                replyMarkup = replyMarkup.orElse(entity.replyMarkup),
                entities = entities.getOrElse(entity.entities),
                editDate = Some(date)
              )
            )
      }
}

sealed trait DialogMessagesRepo {
  def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit]
  def getByRandomId(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): SvcIO[Option[DialogMessageEntity]]
  def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]]
  def update(entity: DialogMessageEntity): SvcIO[Unit] // TODO: record not found
  def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]]
  def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit]
  def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit]
  def reindexAll(): SvcIO[Unit]
  def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit]

  def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])]

  def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]]

  // Get only user text & media messages (excludes service messages)
  def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]]
  def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]]

  // TODO: get messages by range [mappings.last..mappings.head] and apply them recursively
  def get(peer: MessagesPeer.Dialog, from: Int, to: Int): SvcIO[collection.Seq[DialogMessageEntity]] = ???
}

object DialogMessagesRepoPostgresImpl {
  implicit val messagesPeerDialogMeta: Meta[MessagesPeer.Dialog] = Meta[Long].imap(MessagesPeer.Dialog.from)(_.id)

  def apply()(implicit xa: Transactor[SvcIO]): DialogMessagesRepo =
    new DialogMessagesRepoPostgresImpl()
}

// TODO: add partitioning (https://www.postgresql.org/docs/11/ddl-partitioning.html)
final class DialogMessagesRepoPostgresImpl()(implicit xa: Transactor[SvcIO]) extends DialogMessagesRepo {
  import DialogMessagesRepoPostgresImpl._
  import MessageKind.Implicits._
  import TlImplicits._

  private val dialogColumns = Seq(
    "id",
    "dialog_id",
    "user_id",
    "random_id",
    "message",
    "media",
    "action",
    "kind",
    "grouped_id",
    "reply_to_id",
    "fwd_from",
    "reply_markup",
    "entities",
    "date",
    "edit_date",
    "via_bot_id",
    "views",
    "flags",
    "deleted"
  )
  private def dialogColumnsQ = dialogColumns.mkString(",")
  private def dialogRowsQ = dialogColumns.map(_ => "?").mkString(",")

  private val upsertQuery = fs"""
                                |INSERT INTO dialog_messages ($dialogColumnsQ)
                                |VALUES ($dialogRowsQ)
                                |ON CONFLICT (dialog_id, id) DO UPDATE
                                |SET message = EXCLUDED.message, media = EXCLUDED.media, reply_markup = EXCLUDED.reply_markup,
                                |  entities = EXCLUDED.entities, edit_date = EXCLUDED.edit_date, flags = EXCLUDED.flags""".stripMargin

  val messageEntityUpsertMany = Update[DialogMessageEntity](upsertQuery)

  override def upsert(entities: collection.Seq[DialogMessageEntity]): SvcIO[Unit] =
    IO.when(entities.nonEmpty)(messageEntityUpsertMany.updateMany(entities.toVector).transact(xa).unit)

  def getByRandomIdQ(userId: Int, peer: MessagesPeer.Dialog, randomId: Long): Query0[DialogMessageEntity] =
    sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
          FROM dialog_messages
          WHERE dialog_id = ${peer.id} AND user_id = $userId AND random_id = $randomId AND deleted = false
          LIMIT 1""".query[DialogMessageEntity]

  override def getByRandomId(
      userId: Int,
      peer: MessagesPeer.Dialog,
      randomId: Long
  ): SvcIO[Option[DialogMessageEntity]] =
    getByRandomIdQ(userId = userId, peer, randomId = randomId).option.transact(xa)

  // TODO: DRY
  def searchFilters(query: String, fromId: Option[Int], kinds: collection.Seq[MessageKind]): Option[Fragment] = {
    val args = List.newBuilder[Elem]
    val sb = new StringBuilder

    if (query.nonEmpty) {
      sb.append(" AND message_tsv @@ to_tsquery('simple', ?)")
      args += Elem.Arg(query, Put[String])
    }

    fromId.foreach { fromId =>
      sb.append(" AND user_id = ")
      sb.append(fromId)
    }

    if (kinds.nonEmpty) {
      if (kinds.length == 1) {
        sb.append(" AND kind = ")
        sb.append(kinds.head.value)
      } else {
        sb.append(" AND kind IN (")
        val iter = kinds.iterator
        while (iter.hasNext) {
          sb.append(iter.next().value)
          if (iter.hasNext) sb.append(',')
        }
        sb.append(")")
      }
    }

    sb.result() match {
      case sql if sql.nonEmpty => Some(Fragment(sql, args.result()))
      case _                   => None
    }
  }

  def searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchCountQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int): Query0[Int] = {
    val q =
      sql"SELECT COUNT(*)::int FROM dialog_messages WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false" ++ Fragments
        .whereAndOpt(dateFilterSql(minDate, maxDate))
    filters.fold(q)(q ++ _).query[Int]
  }

  private val emptySearch = IO.succeed((0, Nil))

  def searchRangeFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      offsetId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      bottomLimit: Long,
      topLimit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    Fragment
      .const0(filters match {
        case Some(filtersFrg) =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               | fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)} $filtersFrg
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId $filtersFrg ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
        case _ =>
          fs"""|SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
               |   fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
               |FROM (
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id >= $minId ${dateFilter(minDate, maxDate)}
               |ORDER BY id ASC
               |OFFSET $offset
               |LIMIT $topLimit)
               |UNION ALL
               |(SELECT * FROM dialog_messages
               |WHERE dialog_id = $dialogId AND deleted IS FALSE AND id < $maxId ${dateFilter(minDate, maxDate)}
               |ORDER BY id DESC
               |OFFSET $offset
               |LIMIT $bottomLimit)
               |) as _
               |ORDER BY id DESC""".stripMargin
      })
      .query[DialogMessageEntity]
  }

  def searchBottomFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id <= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchTopFilterQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      minDate: Option[Int],
      maxDate: Option[Int],
      offsetId: Int,
      limit: Long,
      offset: Long
  ): Query0[DialogMessageEntity] = {
    val q = filters match {
      case Some(filtersFrg) =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(
            minDate,
            maxDate
          )
        )} """ ++
          filtersFrg ++
          sql" ORDER BY id DESC LIMIT $limit OFFSET $offset"
      case _ =>
        sql"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id, reply_to_id,
                fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
              FROM dialog_messages
              WHERE dialog_id = $dialogId AND id BETWEEN $minId AND $maxId AND deleted = false AND id >= $offsetId ${Fragments.whereAndOpt(
          dateFilterSql(minDate, maxDate)
        )}
              ORDER BY id DESC
              LIMIT $limit
              OFFSET $offset"""
    }
    q.query[DialogMessageEntity]
  }

  def searchLastFilterQ(dialogId: Long, filters: Option[Fragment], minId: Int, maxId: Int, limit: Long, offset: Long): Query0[DialogMessageEntity] =
    searchQ(
      dialogId: Long,
      filters: Option[Fragment],
      minId: Int,
      maxId: Int,
      limit: Long,
      offset: Long
    )

  override def search(
      dialogId: Long,
      query: String,
      fromId: Option[Int],
      kinds: collection.Seq[MessageKind],
      minId: Int,
      maxId: Int,
      limit: Int,
      offset: Int
  ): SvcIO[(Int, collection.Seq[DialogMessageEntity])] =
    if (query.isEmpty && kinds.isEmpty && fromId.isEmpty) emptySearch
    else {
      val filters = searchFilters(SqlHelpers.searchQuery(query), fromId = fromId, kinds)
      if (limit > 0) {
        (for {
          count <- searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique
          xs <- searchQ(dialogId = dialogId, filters, minId = minId, maxId = maxId, limit = limit.toLong, offset = offset.toLong)
            .to[Vector]
        } yield (count, xs)).transact(xa)
      } else searchCountQ(dialogId = dialogId, filters, minId = minId, maxId = maxId).unique.transact(xa).map((_, Nil))
    }

  def getAllByPeersQ(ids: Iterable[(Long, Int)]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(ids) { case (peerId, id) => fs"($peerId, $id)" }
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getAllByPeers(ids: Iterable[(Long, Int)]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (ids.isEmpty) emptySeq
    else getAllByPeersQ(ids).to[Vector].transact(xa)

  def updateQ(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE($message, message),
              media = COALESCE($media, media),
              reply_markup = COALESCE($replyMarkup, reply_markup),
              entities = COALESCE($entities, entities),
              edit_date = $date
          WHERE dialog_id = ${peer.id} AND id = $id AND user_id = $userId AND deleted = false""".update

  override def update(
      userId: Int,
      peer: MessagesPeer.Dialog,
      id: Int,
      message: Option[String],
      media: Option[MessageMedia],
      replyMarkup: Option[ReplyMarkup],
      entities: collection.Seq[TlMessageEntity],
      date: Int
  ): SvcIO[Option[DialogMessageEntity]] =
    updateQ(
      userId = userId,
      peer,
      id = id,
      message = message,
      media,
      replyMarkup,
      entities,
      date = date
    ).withUniqueGeneratedKeys[DialogMessageEntity](dialogColumns: _*).transact(xa).either.map(_.toOption)

  def updateQ(entity: DialogMessageEntity): Update0 =
    sql"""UPDATE dialog_messages
          SET message = COALESCE(${entity.message}, message),
              media = COALESCE(${entity.media}, media),
              reply_markup = COALESCE(${entity.replyMarkup}, reply_markup),
              entities = COALESCE(${entity.entities}, entities),
              edit_date = ${entity.date}
          WHERE dialog_id = ${entity.peer.id} AND id = ${entity.id}
            AND user_id = ${entity.userId} AND deleted = false""".update

  override def update(entity: DialogMessageEntity): SvcIO[Unit] =
    updateQ(entity).run.transact(xa).unit

  private def getQ(valuesQ: String): Query0[DialogMessageEntity] =
    Fragment
      .const0(fs"""SELECT id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _id) ON dialog_id = _dialog_id AND id = _id
        WHERE deleted = false""")
      .query[DialogMessageEntity]

  def getByIdRefsQ(refs: Iterable[DialogMessageRef.Id]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})"))

  override def getByIdRefs(refs: Iterable[DialogMessageRef.Id]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByIdRefsQ(refs).to[Vector].transact(xa)

  def getByRefKeysQ(userId: Int, keys: Iterable[Long]): Query0[DialogMessageEntity] =
    getQ(SqlHelpers.unsafeRawValues(keys) { key =>
      val peerUserId = (key >> 32).toInt
      val dialogId = MessagesPeer.Dialog.id(userId, peerUserId)
      val messageId = key.toInt
      fs"($dialogId, $messageId)"
    })

  // TODO: add column and index ???
  override def getByRefKeys(userId: Int, keys: Iterable[Long]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (keys.isEmpty) emptySeq
    else getByRefKeysQ(userId = userId, keys).to[Vector].transact(xa)

  def getByRandomRefsQ(refs: Iterable[DialogMessageRef.Random]): Query0[DialogMessageEntity] = {
    val valuesQ = SqlHelpers.unsafeRawValues(refs)(ref => fs"(${ref.dialogId}, ${ref.userId}, ${ref.randomId})")
    Fragment
      .const0(fs"""SELECT DISTINCT ON (dialog_id, random_id) id, dialog_id, user_id, random_id, message, media, action, kind, grouped_id,
          reply_to_id, fwd_from, reply_markup, entities, date, edit_date, via_bot_id, views, flags, deleted
        FROM dialog_messages
        INNER JOIN $valuesQ AS _(_dialog_id, _user_id, _random_id) ON dialog_id = _dialog_id AND user_id = _user_id
          AND random_id = _random_id
        WHERE deleted = false""")
      .query[DialogMessageEntity]
  }

  override def getByRandomRefs(refs: Iterable[DialogMessageRef.Random]): SvcIO[collection.Seq[DialogMessageEntity]] =
    if (refs.isEmpty) emptySeq
    else getByRandomRefsQ(refs).to[Vector].transact(xa)

  def markAsDeletedQ(refs: Iterable[DialogMessageRef.Id]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(refs)(ref => fs"(${ref.dialogId}, ${ref.messageId})")
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE (dialog_id, id) IN $valuesQ")
      .update
  }

  override def markAsDeleted(messageIds: Iterable[DialogMessageRef.Id]): SvcIO[Unit] =
    if (messageIds.isEmpty) IO.unit
    else markAsDeletedQ(messageIds).run.transact(xa).unit

  def clearAsDeletedQ(peerMaxIds: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRawOr(peerMaxIds) { case (dialogId, maxId) =>
      fs"(dialog_id = $dialogId AND id <= $maxId)"
    }
    Fragment
      .const0(fs"UPDATE dialog_messages SET deleted = true WHERE deleted = false AND $valuesQ")
      .update
  }

  override def clearAsDeleted(peerMaxIds: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(peerMaxIds.nonEmpty)(clearAsDeletedQ(peerMaxIds).run.transact(xa).unit)

  val reindexAllQ =
    sql"""UPDATE dialog_messages
          SET message_tsv = to_tsvector('simple', message)
          WHERE message IS NOT NULL AND message_tsv IS NULL""".update

  override def reindexAll(): SvcIO[Unit] = reindexAllQ.run.transact(xa).unit

  def reindexQ(keys: Iterable[(Long, Int)]): Update0 = {
    val valuesQ = SqlHelpers.unsafeRaw(keys) { case (dialogId, messageId) =>
      fs"($dialogId, $messageId)"
    }
    Fragment
      .const0(
        fs"UPDATE dialog_messages SET message_tsv = to_tsvector('simple', message) WHERE (dialog_id, id) IN $valuesQ AND deleted = false"
      )
      .update
  }

  override def reindex(keys: Iterable[(Long, Int)]): SvcIO[Unit] =
    IO.when(keys.nonEmpty)(reindexQ(keys).run.transact(xa).unit)

  private def dateFilter(minDate: Option[Int], maxDate: Option[Int]): String =
    if (minDate.isEmpty || maxDate.isEmpty)
      ""
    else
      minDate.zip(maxDate).map({ case (mn, mx) => fs"AND date >= $mn AND date <= $mx " }).getOrElse("")

  private def dateFilterSql(minDate: Option[Int], maxDate: Option[Int]): Option[Fragment] = {
    if (minDate.isEmpty || maxDate.isEmpty)
      None
    else
      Some(sql" ${dateFilter(minDate, maxDate)}")
  }
  private val emptySeq = IO.succeed(Nil)
}

object DialogMessagesRepo {
  def apply()(implicit xa: Transactor[SvcIO]) = DialogMessagesRepoPostgresImpl()
}

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:53:52 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

Mar 23, 2021 2:53:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 60
package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:53:55 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:53:55 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:53:56 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:53:57 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:53:57 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

Mar 23, 2021 2:53:58 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
file%3A%2F%2F%2FUsers%2Fstan%2FDev%2Ftawa_recover%2Fmodules%2Fserver%2Fsrc%2Fmain%2Fscala%2Fim%2Fchat%2Fservices%2Fsearch%2FSearchFlow.scala:129: error: } expected but case found
              case chat: UserDialog.Chat =>
              ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$24(ScalametaParser.scala:2469)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2410)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2954)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2910)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2890)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2899)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5021)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$7(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.bracelessPackageStats$1(ScalametaParser.scala:5016)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$9(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5027)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.23 14:53:59 WARN  no build target for: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/search/SearchFlow.scala[0m
package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
                }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{MessageEntity, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          dialog.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              }
              case chat: UserDialog.Chat =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(chat.lastClearPeerMsgId, cmd.minId) else chat.lastClearPeerMsgId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, cmd.maxId) else chat.maxPeerMsgId
                chatMessagesRepo
                  .search(
                    chatId = chat.chatId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ConversationMessages(
                        userId = cmd.userId,
                        cmd.session,
                        chat.conversationPeer,
                        totalCount = count,
                        limit = cmd.limit,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ConversationMessages(
                          userId = cmd.userId,
                          cmd.session,
                          chat.conversationPeer,
                          totalCount = 0,
                          limit = cmd.limit,
                          Nil
                        ) :: Nil
                    )
                  }
              case channel: UserDialog.Channel =>
                // TODO: date filter, offsetId
                val minId = if (cmd.minId > 0) math.max(channel.lastClearId, cmd.minId) else channel.lastClearId
                val maxId = if (cmd.maxId > 0 && cmd.maxId < Int.MaxValue) math.min(channel.topMessage, cmd.maxId) else channel.topMessage
                channelMessagesRepo
                  .search(
                    channelId = channel.channelId,
                    cmd.query,
                    fromId = cmd.fromId,
                    kinds = MessageKind.from(cmd.filter),
                    minId = minId,
                    maxId = maxId,
                    limit = cmd.limit,
                    offset = math.max(0, cmd.addOffset)
                  )
                  .map { case (count, messages) =>
                    SenderResponse
                      .ChannelMessages(
                        userId = cmd.userId,
                        cmd.session,
                        channelId = channel.channelId,
                        pts = channel.pts,
                        totalCount = count,
                        messages
                      ) :: Nil
                  }
                  .sandbox
                  .catchAll { ex =>
                    logger.warn(ex.squash)
                    IO.succeed(
                      SenderResponse
                        .ChannelMessages(
                          userId = cmd.userId,
                          cmd.session,
                          channelId = channel.channelId,
                          pts = channel.pts,
                          totalCount = 0,
                          Nil
                        ) :: Nil
                    )
                  }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(cmd.userId, dialogIds.result(), filter, limit = cmd.limit, offset = cmd.offset)
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }

                messagesView
                  .search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit)
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = cmd.limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = cmd.limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit))
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import com.github.plokhotnyuk.fsi._
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{LimitedMessageFilter, MessageEntity, MessageFilter, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
              }
              case chat: UserDialog.Chat => {
                chatMessagesRepo
                  .getByRefKeys(Array(MessageEntity.refKey(peerId = chat.chatId, id = chat.lastClearId)))
                  .map(_.head.date)
                  .zipPar(chatMessagesRepo.getByRefKeys(Array(MessageEntity.refKey(peerId = chat.chatId, id = chat.lastMessage.id))).map(_.head.date))
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    logger.warn(fs"SearchServiceCommand UserDialog.Chat $chat ${cmd.pagination} minDate: $minDate maxDate: $maxDate")

                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(chat.lastClearPeerMsgId, pagination.minId) else chat.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, pagination.maxId)
                          else chat.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (chat.lastClearPeerMsgId, chat.maxPeerMsgId, settings.services.messages.serverLimit)
                    }
                    chatMessagesRepo
                      .search(
                        chatId = chat.chatId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            chat.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              chat.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
              }
              case channel: UserDialog.Channel => {
                channelMessagesRepo
                  .getByRefKeys(Array(MessageEntity.refKey(peerId = channel.channelId, id = channel.lastClearId)))
                  .map(_.head.date)
                  .zipPar(
                    channelMessagesRepo
                      .getByRefKeys(Array(MessageEntity.refKey(peerId = channel.channelId, id = channel.lastMessage.id)))
                      .map(_.head.date)
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    logger.warn(fs"SearchServiceCommand UserDialog.Channel $channel ${cmd.pagination} minDate: $minDate maxDate: $maxDate")

                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(channel.lastClearId, pagination.minId) else channel.lastClearId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(channel.topMessage, pagination.maxId)
                          else channel.topMessage,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (channel.lastClearId, channel.topMessage, settings.services.messages.serverLimit)
                    }
                    channelMessagesRepo
                      .search(
                        channelId = channel.channelId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ChannelMessages(
                            userId = cmd.userId,
                            cmd.session,
                            channelId = channel.channelId,
                            pts = channel.pts,
                            totalCount = count,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ChannelMessages(
                              userId = cmd.userId,
                              cmd.session,
                              channelId = channel.channelId,
                              pts = channel.pts,
                              totalCount = 0,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
              }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            val limit = cmd.pagination match {
              case pagination: LimitedMessageFilter =>
                pagination.limit
              case pagination: MessageFilter =>
                settings.services.messages.serverLimit
            }
            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(
                  cmd.userId,
                  dialogIds.result(),
                  filter,
                  limit = limit,
                  offset = cmd.offset,
                  pagination = Some(cmd.pagination)
                )
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }
                messagesView
                  .search(
                    userId = cmd.userId,
                    query = cmd.query,
                    channelIds = channelIds.result(),
                    limit = limit,
                    pagination = Some(cmd.pagination)
                  )
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit, pagination = None)
              )
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}

package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import com.github.plokhotnyuk.fsi._
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{LimitedMessageFilter, MessageEntity, MessageFilter, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
              }
              case chat: UserDialog.Chat => {
                chatMessagesRepo
                  .getByRefKeys(Array(MessageEntity.refKey(peerId = chat.chatId, id = chat.lastClearId)))
                  .map(_.head.date)
                  .zipPar(chatMessagesRepo.getByRefKeys(Array(MessageEntity.refKey(peerId = chat.chatId, id = chat.lastMessage.id))).map(_.head.date))
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    logger.warn(fs"SearchServiceCommand UserDialog.Chat $chat ${cmd.pagination} minDate: $minDate maxDate: $maxDate")

                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(chat.lastClearPeerMsgId, pagination.minId) else chat.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, pagination.maxId)
                          else chat.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (chat.lastClearPeerMsgId, chat.maxPeerMsgId, settings.services.messages.serverLimit)
                    }
                    chatMessagesRepo
                      .search(
                        chatId = chat.chatId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            chat.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              chat.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
              }
              case channel: UserDialog.Channel => {
                channelMessagesRepo
                  .getByRefKeys(Array(MessageEntity.refKey(peerId = channel.channelId, id = channel.lastClearId)))
                  .map(_.head.date)
                  .zipPar(
                    channelMessagesRepo
                      .getByRefKeys(Array(MessageEntity.refKey(peerId = channel.channelId, id = channel.lastMessage.id)))
                      .map(_.head.date)
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    logger.warn(fs"SearchServiceCommand UserDialog.Channel $channel ${cmd.pagination} minDate: $minDate maxDate: $maxDate")

                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(channel.lastClearId, pagination.minId) else channel.lastClearId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(channel.topMessage, pagination.maxId)
                          else channel.topMessage,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (channel.lastClearId, channel.topMessage, settings.services.messages.serverLimit)
                    }
                    channelMessagesRepo
                      .search(
                        channelId = channel.channelId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ChannelMessages(
                            userId = cmd.userId,
                            cmd.session,
                            channelId = channel.channelId,
                            pts = channel.pts,
                            totalCount = count,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ChannelMessages(
                              userId = cmd.userId,
                              cmd.session,
                              channelId = channel.channelId,
                              pts = channel.pts,
                              totalCount = 0,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
              }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            val limit = cmd.pagination match {
              case pagination: LimitedMessageFilter =>
                pagination.limit
              case pagination: MessageFilter =>
                settings.services.messages.serverLimit
            }
            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(
                  cmd.userId,
                  dialogIds.result(),
                  filter,
                  limit = limit,
                  offset = cmd.offset,
                  pagination = Some(cmd.pagination)
                )
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }
                messagesView
                  .search(
                    userId = cmd.userId,
                    query = cmd.query,
                    channelIds = channelIds.result(),
                    limit = limit,
                    pagination = Some(cmd.pagination)
                  )
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit, pagination = None)
              )
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}
package im.chat
package services
package search

import akka.stream.scaladsl._
import akka.stream.{ActorAttributes, Supervision}
import com.github.plokhotnyuk.fsi._
import doobie.Transactor
import org.apache.logging.log4j.scala.Logging
import org.roaringbitmap.buffer.MutableRoaringBitmap
import zio.IO

import im.chat.common.Username
import im.chat.config.Settings
import im.chat.services.channels.messages.ChannelMessagesRepo
import im.chat.services.chats.repos.ChatMessagesRepo
import im.chat.services.contacts.ContactsRepo
import im.chat.services.dialogs.DialogMessagesRepo
import im.chat.services.messages.{LimitedMessageFilter, MessageEntity, MessageFilter, MessageKind}
import im.chat.services.users.dialogs.UserDialog
import im.chat.services.users.repos.{UsernamesRepo, UsersRepo}
import im.chat.tl.schema.InputMessagesFilterPhoneCalls
import im.chat.utils.{BitmapUtils, RTS}

object SearchFlow extends Logging {
  import SearchServiceCommand._

  val Shards = 8

  def apply()(implicit settings: Settings, xa: Transactor[SvcIO]): Flow[SearchServiceCommand, ServiceMessage, _] = {
    import settings.services.search._

    val dialogMessagesRepo = DialogMessagesRepo()
    val chatMessagesRepo = ChatMessagesRepo()
    val channelMessagesRepo = ChannelMessagesRepo()
    val messagesView = MessagesView()
    val contactsRepo = ContactsRepo()
    val usersRepo = UsersRepo()
    val searchTitlesRepo = ChatSearchTitlesRepo()
    val usernamesRepo = UsernamesRepo()

    Flow[SearchServiceCommand]
      .groupBy(Shards, _.userId % Shards)
      .mapAsyncUnordered[List[ServiceMessage]](parallelism = 2) { cmd =>
        RTS.unsafeRunToFuture(cmd match {
          case cmd: ByDialog =>
            cmd.userDialog match {
              case dialog: UserDialog.Private => {
                val currentDate = 0 // TODO: BAC-131
                dialogMessagesRepo
                  .getByRefKeys(userId = cmd.userId, Seq(dialog.lastClearId))
                  .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  .zipPar(
                    dialogMessagesRepo
                      .getByRefKeys(userId = cmd.userId, Seq(dialog.lastMessage.id))
                      .map(res => res.headOption.map(_.date).getOrElse(currentDate))
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(dialog.lastClearPeerMsgId, pagination.minId) else dialog.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(dialog.maxPeerMsgId, pagination.maxId)
                          else dialog.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (dialog.lastClearPeerMsgId, dialog.maxPeerMsgId, settings.services.messages.serverLimit)
                    }

                    logger.warn(fs"SearchServiceCommand UserDialog.Private $dialog ${cmd.pagination} minDate: $minDate maxDate: $maxDate")
                    dialogMessagesRepo
                      .search(
                        dialogId = dialog.dialogId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            dialog.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              dialog.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
              }
              case chat: UserDialog.Chat => {
                chatMessagesRepo
                  .getByRefKeys(Array(MessageEntity.refKey(peerId = chat.chatId, id = chat.lastClearId)))
                  .map(_.head.date)
                  .zipPar(chatMessagesRepo.getByRefKeys(Array(MessageEntity.refKey(peerId = chat.chatId, id = chat.lastMessage.id))).map(_.head.date))
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    logger.warn(fs"SearchServiceCommand UserDialog.Chat $chat ${cmd.pagination} minDate: $minDate maxDate: $maxDate")

                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(chat.lastClearPeerMsgId, pagination.minId) else chat.lastClearPeerMsgId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(chat.maxPeerMsgId, pagination.maxId)
                          else chat.maxPeerMsgId,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (chat.lastClearPeerMsgId, chat.maxPeerMsgId, settings.services.messages.serverLimit)
                    }
                    chatMessagesRepo
                      .search(
                        chatId = chat.chatId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ConversationMessages(
                            userId = cmd.userId,
                            cmd.session,
                            chat.conversationPeer,
                            totalCount = count,
                            limit = limit,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ConversationMessages(
                              userId = cmd.userId,
                              cmd.session,
                              chat.conversationPeer,
                              totalCount = 0,
                              limit = limit,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
              }
              case channel: UserDialog.Channel => {
                channelMessagesRepo
                  .getByRefKeys(Array(MessageEntity.refKey(peerId = channel.channelId, id = channel.lastClearId)))
                  .map(_.head.date)
                  .zipPar(
                    channelMessagesRepo
                      .getByRefKeys(Array(MessageEntity.refKey(peerId = channel.channelId, id = channel.lastMessage.id)))
                      .map(_.head.date)
                  )
                  .flatMap { case (lastClearDate, lastMaxDate) =>
                    val minDate =
                      if (cmd.pagination.dateRange.isDefined) math.max(lastClearDate, cmd.pagination.dateRange.get._1) else lastClearDate
                    val maxDate =
                      if (cmd.pagination.dateRange.isDefined && cmd.pagination.dateRange.get._2 < Int.MaxValue)
                        math.max(lastMaxDate, cmd.pagination.dateRange.get._2)
                      else lastMaxDate
                    logger.warn(fs"SearchServiceCommand UserDialog.Channel $channel ${cmd.pagination} minDate: $minDate maxDate: $maxDate")

                    val (minId, maxId, limit) = cmd.pagination match {
                      case pagination: LimitedMessageFilter =>
                        (
                          if (pagination.minId > 0) math.max(channel.lastClearId, pagination.minId) else channel.lastClearId,
                          if (pagination.maxId > 0 && pagination.maxId < Int.MaxValue) math.min(channel.topMessage, pagination.maxId)
                          else channel.topMessage,
                          pagination.limit
                        )
                      case pagination: MessageFilter =>
                        (channel.lastClearId, channel.topMessage, settings.services.messages.serverLimit)
                    }
                    channelMessagesRepo
                      .search(
                        channelId = channel.channelId,
                        cmd.query,
                        fromId = cmd.fromId,
                        kinds = MessageKind.from(cmd.filter),
                        minId = minId,
                        maxId = maxId,
                        pagination = cmd.pagination
                      )
                      .map { case (count, messages) =>
                        SenderResponse
                          .ChannelMessages(
                            userId = cmd.userId,
                            cmd.session,
                            channelId = channel.channelId,
                            pts = channel.pts,
                            totalCount = count,
                            messages
                          ) :: Nil
                      }
                      .sandbox
                      .catchAll { ex =>
                        logger.warn(ex.squash)
                        IO.succeed(
                          SenderResponse
                            .ChannelMessages(
                              userId = cmd.userId,
                              cmd.session,
                              channelId = channel.channelId,
                              pts = channel.pts,
                              totalCount = 0,
                              Nil
                            ) :: Nil
                        )
                      }
                  }
              }
            }
          case cmd: ByDialogs =>
            // TODO: rewrite !!!

            val limit = cmd.pagination match {
              case pagination: LimitedMessageFilter =>
                pagination.limit
              case pagination: MessageFilter =>
                settings.services.messages.serverLimit
            }
            (cmd.filter match {
              case filter: InputMessagesFilterPhoneCalls =>
                val dialogIds = Array.newBuilder[Long]
                dialogIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Private => dialogIds += userDialog.dialogId
                  case _                              =>
                }

                messagesView.search(
                  cmd.userId,
                  dialogIds.result(),
                  filter,
                  limit = limit,
                  offset = cmd.offset,
                  pagination = Some(cmd.pagination)
                )
              case _ =>
                val channelIds = Array.newBuilder[Int]
                channelIds.sizeHint(cmd.userDialogs.size)

                cmd.userDialogs.foreach {
                  case userDialog: UserDialog.Channel => channelIds += userDialog.channelId
                  case _                              =>
                }
                messagesView
                  .search(
                    userId = cmd.userId,
                    query = cmd.query,
                    channelIds = channelIds.result(),
                    limit = limit,
                    pagination = Some(cmd.pagination)
                  )
            })
              .map { messages =>
                SenderResponse
                  .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = messages.length, limit = limit, messages) :: Nil
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse
                    .FoundTlMessages(userId = cmd.userId, cmd.session, totalCount = 0, limit = limit, Nil) :: Nil
                )
              }
          case cmd: Contacts =>
            //TODO: global search

            val dialogKeys = Array.newBuilder[Long]
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds)(channelId => dialogKeys += UserDialog.Channel.getUserKey(channelId))

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                searchTitlesRepo.search(
                  keys = dialogKeys.result(),
                  cmd.query,
                  public = cmd.query.length >= 5,
                  limit = cmd.limit
                )
              )
              .flatMap { case ((foundContactIds, contactIds), titleKeys) =>
                // TODO: rethink & rewrite !!!
                val userIds = new MutableRoaringBitmap
                val chatIds = new MutableRoaringBitmap
                val channelIds = new MutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                titleKeys.foreach { key =>
                  val peerId = key.toInt
                  if (UserDialog.isChat(key)) chatIds.add(peerId)
                  else channelIds.add(peerId)
                }

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach { owner =>
                      if (owner.isUser) userIds.add(owner.ownerId)
                      else if (owner.isChannel) channelIds.add(owner.ownerId)
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.ContactsFound(
                      userId = cmd.userId,
                      cmd.session,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.ContactsFound(
                    userId = cmd.userId,
                    cmd.session,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
          case cmd: Global =>
            //TODO: global search
            val channelsSize = cmd.channelIds.getCardinality

            val channelIds = Array.newBuilder[Int]
            channelIds.sizeHint(channelsSize)

            val dialogKeys = Array.newBuilder[Long]
            dialogKeys.sizeHint(channelsSize + cmd.chatIds.getCardinality)
            BitmapUtils.forEach(cmd.chatIds)(chatId => dialogKeys += UserDialog.Chat.getUserKey(chatId))
            BitmapUtils.forEach(cmd.channelIds) { channelId =>
              channelIds += channelId
              dialogKeys += UserDialog.Channel.getUserKey(channelId)
            }

            contactsRepo
              .search(userId = cmd.userId, cmd.query, limit = cmd.limit)
              .zipPar(contactsRepo.getContactUserIds(userId = cmd.userId))
              .zipPar(
                messagesView.search(userId = cmd.userId, query = cmd.query, channelIds = channelIds.result(), limit = cmd.limit, pagination = None)
              )
              .flatMap { case ((foundContactIds, contactIds), messages) =>
                // TODO: rethink & rewrite !!!
                val linkedIds = MessageEntity.getLinkedIds(messages, includeSenderId = true, includeToPeer = true)
                val userIds = linkedIds.userIds.toMutableRoaringBitmap
                val chatIds = linkedIds.chatIds.toMutableRoaringBitmap
                val channelIds = linkedIds.channelIds.toMutableRoaringBitmap

                foundContactIds.foreach(contactUserId => userIds.add(contactUserId))

                val unknownUserIds = new MutableRoaringBitmap
                val contactUserIds = BitmapUtils.from(contactIds)
                BitmapUtils.forEach(cmd.participantIds) { participantId =>
                  if (!contactUserIds.contains(participantId)) unknownUserIds.add(participantId)
                }

                val username = Username.parse(cmd.query.replaceFirst("@", "").trim).map(_.get)
                val byUsernameAction = username match {
                  case Some(username) => usernamesRepo.search(query = username, limit = searchByUsernameLimit)
                  case _              => emptySeq
                }

                usersRepo
                  .search(cmd.query, ids = unknownUserIds.toArray, username = username, limit = cmd.limit)
                  .zipPar(byUsernameAction)
                  .map { case (unknownUsers, usernameOwners) =>
                    usernameOwners.foreach {
                      case owner if owner.isUser    => userIds.add(owner.ownerId)
                      case owner if owner.isChannel => channelIds.add(owner.ownerId)
                      case _                        =>
                    }

                    unknownUsers.foreach(userIds.add)

                    SenderResponse.GlobalSearchResult(
                      userId = cmd.userId,
                      cmd.session,
                      messages,
                      userIds = userIds,
                      chatIds = chatIds,
                      channelIds = channelIds
                    ) :: Nil
                  }
              }
              .sandbox
              .catchAll { ex =>
                logger.warn(ex.squash)
                IO.succeed(
                  SenderResponse.GlobalSearchResult(
                    userId = cmd.userId,
                    cmd.session,
                    Nil,
                    userIds = BitmapUtils.empty,
                    chatIds = BitmapUtils.empty,
                    channelIds = BitmapUtils.empty
                  ) :: Nil
                )
              }
        })
      }
      .withAttributes(ActorAttributes.supervisionStrategy { ex =>
        logger.error("Search flow failure", ex)
        Supervision.Resume
      })
      .named("SearchFlow")
      .async
      .mergeSubstreams
      .mapConcat(identity)
  }

  private val emptySeq = IO.succeed(Nil)
}
[0m2021.03.23 19:12:27 ERROR text document: file:///Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/search/SearchFlow.scala
java.nio.file.NoSuchFileException: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/search/SearchFlow.scala
	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
	at sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:215)
	at java.nio.file.Files.newByteChannel(Files.java:369)
	at java.nio.file.Files.newByteChannel(Files.java:415)
	at java.nio.file.Files.readAllBytes(Files.java:3207)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:77)
	at java.util.HashMap.compute(HashMap.java:1232)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2688)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:76)
	at scala.meta.internal.metals.AggregateSemanticdbs.loop$1(AggregateSemanticdbs.scala:30)
	at scala.meta.internal.metals.AggregateSemanticdbs.textDocument(AggregateSemanticdbs.scala:36)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:259)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:74)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$didChange$1(MetalsLanguageServer.scala:1049)
	at scala.concurrent.Future.$anonfun$flatMap$1(Future.scala:307)
	at scala.concurrent.impl.Promise.$anonfun$transformWith$1(Promise.scala:41)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
	at java.lang.Thread.run(Thread.java:844)
[0m
[0m2021.03.23 19:12:27 ERROR text document: file:///Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/search/SearchFlow.scala
java.nio.file.NoSuchFileException: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/search/SearchFlow.scala
	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
	at sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:215)
	at java.nio.file.Files.newByteChannel(Files.java:369)
	at java.nio.file.Files.newByteChannel(Files.java:415)
	at java.nio.file.Files.readAllBytes(Files.java:3207)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:77)
	at java.util.HashMap.compute(HashMap.java:1232)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2688)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:76)
	at scala.meta.internal.metals.AggregateSemanticdbs.loop$1(AggregateSemanticdbs.scala:30)
	at scala.meta.internal.metals.AggregateSemanticdbs.textDocument(AggregateSemanticdbs.scala:36)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:259)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:74)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$didChange$1(MetalsLanguageServer.scala:1049)
	at scala.concurrent.Future.$anonfun$flatMap$1(Future.scala:307)
	at scala.concurrent.impl.Promise.$anonfun$transformWith$1(Promise.scala:41)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
	at java.lang.Thread.run(Thread.java:844)
[0m
[0m2021.03.23 19:12:27 ERROR text document: file:///Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/search/SearchFlow.scala
java.nio.file.NoSuchFileException: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/search/SearchFlow.scala
	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
	at sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:215)
	at java.nio.file.Files.newByteChannel(Files.java:369)
	at java.nio.file.Files.newByteChannel(Files.java:415)
	at java.nio.file.Files.readAllBytes(Files.java:3207)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:77)
	at java.util.HashMap.compute(HashMap.java:1232)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2688)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:76)
	at scala.meta.internal.metals.AggregateSemanticdbs.loop$1(AggregateSemanticdbs.scala:30)
	at scala.meta.internal.metals.AggregateSemanticdbs.textDocument(AggregateSemanticdbs.scala:36)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:259)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:74)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$didChange$1(MetalsLanguageServer.scala:1049)
	at scala.concurrent.Future.$anonfun$flatMap$1(Future.scala:307)
	at scala.concurrent.impl.Promise.$anonfun$transformWith$1(Promise.scala:41)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
	at java.lang.Thread.run(Thread.java:844)
[0m
[0m2021.03.23 19:12:27 ERROR text document: file:///Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/search/SearchFlow.scala
java.nio.file.NoSuchFileException: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/search/SearchFlow.scala
	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
	at sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:215)
	at java.nio.file.Files.newByteChannel(Files.java:369)
	at java.nio.file.Files.newByteChannel(Files.java:415)
	at java.nio.file.Files.readAllBytes(Files.java:3207)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:77)
	at java.util.HashMap.compute(HashMap.java:1232)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2688)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:76)
	at scala.meta.internal.metals.AggregateSemanticdbs.loop$1(AggregateSemanticdbs.scala:30)
	at scala.meta.internal.metals.AggregateSemanticdbs.textDocument(AggregateSemanticdbs.scala:36)
	at scala.meta.internal.metals.CodeLensProvider.findLenses(CodeLensProvider.scala:22)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeLens$2(MetalsLanguageServer.scala:1464)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeLens$1(MetalsLanguageServer.scala:1462)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
	at java.lang.Thread.run(Thread.java:844)
[0m
[0m2021.03.23 19:12:27 ERROR text document: file:///Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/search/SearchFlow.scala
java.nio.file.NoSuchFileException: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/search/SearchFlow.scala
	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
	at sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:215)
	at java.nio.file.Files.newByteChannel(Files.java:369)
	at java.nio.file.Files.newByteChannel(Files.java:415)
	at java.nio.file.Files.readAllBytes(Files.java:3207)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:77)
	at java.util.HashMap.compute(HashMap.java:1232)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2688)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:76)
	at scala.meta.internal.metals.AggregateSemanticdbs.loop$1(AggregateSemanticdbs.scala:30)
	at scala.meta.internal.metals.AggregateSemanticdbs.textDocument(AggregateSemanticdbs.scala:36)
	at scala.meta.internal.metals.CodeLensProvider.findLenses(CodeLensProvider.scala:22)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeLens$2(MetalsLanguageServer.scala:1464)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeLens$1(MetalsLanguageServer.scala:1462)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
	at java.lang.Thread.run(Thread.java:844)
[0m
Mar 23, 2021 7:12:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 115
[0m2021.03.23 19:12:30 ERROR text document: file:///Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/dialogs/DialogMessagesRepo.scala
java.nio.file.NoSuchFileException: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/dialogs/DialogMessagesRepo.scala
	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
	at sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:215)
	at java.nio.file.Files.newByteChannel(Files.java:369)
	at java.nio.file.Files.newByteChannel(Files.java:415)
	at java.nio.file.Files.readAllBytes(Files.java:3207)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:77)
	at java.util.HashMap.compute(HashMap.java:1232)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2688)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:76)
	at scala.meta.internal.metals.AggregateSemanticdbs.loop$1(AggregateSemanticdbs.scala:30)
	at scala.meta.internal.metals.AggregateSemanticdbs.textDocument(AggregateSemanticdbs.scala:36)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.currentDocument(SyntheticsDecorationProvider.scala:259)
	at scala.meta.internal.decorations.SyntheticsDecorationProvider.publishSynthetics(SyntheticsDecorationProvider.scala:74)
	at scala.meta.internal.metals.MetalsLanguageServer.didFocus(MetalsLanguageServer.scala:997)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:514)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
	at java.lang.Thread.run(Thread.java:844)
[0m
[0m2021.03.23 19:12:31 ERROR text document: file:///Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/dialogs/DialogMessagesRepo.scala
java.nio.file.NoSuchFileException: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/dialogs/DialogMessagesRepo.scala
	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
	at sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:215)
	at java.nio.file.Files.newByteChannel(Files.java:369)
	at java.nio.file.Files.newByteChannel(Files.java:415)
	at java.nio.file.Files.readAllBytes(Files.java:3207)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:77)
	at java.util.HashMap.compute(HashMap.java:1232)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2688)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:76)
	at scala.meta.internal.metals.AggregateSemanticdbs.loop$1(AggregateSemanticdbs.scala:30)
	at scala.meta.internal.metals.AggregateSemanticdbs.textDocument(AggregateSemanticdbs.scala:36)
	at scala.meta.internal.metals.CodeLensProvider.findLenses(CodeLensProvider.scala:22)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeLens$2(MetalsLanguageServer.scala:1464)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeLens$1(MetalsLanguageServer.scala:1462)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
	at java.lang.Thread.run(Thread.java:844)
[0m
[0m2021.03.23 19:12:31 ERROR text document: file:///Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/dialogs/DialogMessagesRepo.scala
java.nio.file.NoSuchFileException: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/dialogs/DialogMessagesRepo.scala
	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
	at sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:215)
	at java.nio.file.Files.newByteChannel(Files.java:369)
	at java.nio.file.Files.newByteChannel(Files.java:415)
	at java.nio.file.Files.readAllBytes(Files.java:3207)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:77)
	at java.util.HashMap.compute(HashMap.java:1232)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2688)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:76)
	at scala.meta.internal.metals.AggregateSemanticdbs.loop$1(AggregateSemanticdbs.scala:30)
	at scala.meta.internal.metals.AggregateSemanticdbs.textDocument(AggregateSemanticdbs.scala:36)
	at scala.meta.internal.metals.CodeLensProvider.findLenses(CodeLensProvider.scala:22)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeLens$2(MetalsLanguageServer.scala:1464)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeLens$1(MetalsLanguageServer.scala:1462)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
	at java.lang.Thread.run(Thread.java:844)
[0m
[0m2021.03.23 19:12:30 ERROR text document: file:///Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/dialogs/DialogMessagesRepo.scala
java.nio.file.NoSuchFileException: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/dialogs/DialogMessagesRepo.scala
	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
	at sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:215)
	at java.nio.file.Files.newByteChannel(Files.java:369)
	at java.nio.file.Files.newByteChannel(Files.java:415)
	at java.nio.file.Files.readAllBytes(Files.java:3207)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:77)
	at java.util.HashMap.compute(HashMap.java:1232)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2688)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:76)
	at scala.meta.internal.metals.AggregateSemanticdbs.loop$1(AggregateSemanticdbs.scala:30)
	at scala.meta.internal.metals.AggregateSemanticdbs.textDocument(AggregateSemanticdbs.scala:36)
	at scala.meta.internal.metals.MetalsLanguageServer.definitionOrReferences(MetalsLanguageServer.scala:2450)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$definition$1(MetalsLanguageServer.scala:1253)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLanguageServer.definition(MetalsLanguageServer.scala:1252)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:514)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
	at java.lang.Thread.run(Thread.java:844)
[0m
[0m2021.03.23 19:12:30 WARN  no build tool detected in workspace '/Users/stan/Dev/cv'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. [0m
[0m2021.03.23 19:12:30 ERROR text document: file:///Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/dialogs/DialogMessagesRepo.scala
java.nio.file.NoSuchFileException: /Users/stan/Dev/tawa_recover/modules/server/src/main/scala/im/chat/services/dialogs/DialogMessagesRepo.scala
	at sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
	at sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:215)
	at java.nio.file.Files.newByteChannel(Files.java:369)
	at java.nio.file.Files.newByteChannel(Files.java:415)
	at java.nio.file.Files.readAllBytes(Files.java:3207)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.metals.InteractiveSemanticdbs.$anonfun$textDocument$1(InteractiveSemanticdbs.scala:77)
	at java.util.HashMap.compute(HashMap.java:1232)
	at java.util.Collections$SynchronizedMap.compute(Collections.java:2688)
	at scala.meta.internal.metals.InteractiveSemanticdbs.textDocument(InteractiveSemanticdbs.scala:76)
	at scala.meta.internal.metals.AggregateSemanticdbs.loop$1(AggregateSemanticdbs.scala:30)
	at scala.meta.internal.metals.AggregateSemanticdbs.textDocument(AggregateSemanticdbs.scala:36)
	at scala.meta.internal.metals.DefinitionProvider.definition(DefinitionProvider.scala:68)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$definitionResult$1(MetalsLanguageServer.scala:2516)
	at scala.meta.internal.metals.TimerProvider.timedThunk(TimerProvider.scala:25)
	at scala.meta.internal.metals.MetalsLanguageServer.definitionResult(MetalsLanguageServer.scala:2516)
	at scala.meta.internal.metals.MetalsLanguageServer.definitionOrReferences(MetalsLanguageServer.scala:2492)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$definition$1(MetalsLanguageServer.scala:1253)
	at scala.meta.internal.metals.CancelTokens$.future(CancelTokens.scala:38)
	at scala.meta.internal.metals.MetalsLanguageServer.definition(MetalsLanguageServer.scala:1252)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.request(GenericEndpoint.java:120)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleRequest(RemoteEndpoint.java:261)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:190)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:514)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
	at java.lang.Thread.run(Thread.java:844)
[0m
Mar 23, 2021 7:14:21 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Mar 23, 2021 7:14:38 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Mar 23, 2021 7:15:02 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
[0m2021.03.23 19:15:29 INFO  shutting down Metals[0m
[0m2021.03.24 19:22:28 INFO  Started: Metals version 0.10.0 in workspace '/Users/stan/Dev/cv' for client vscode 1.54.3.[0m
[0m2021.03.24 19:22:38 INFO  time: initialize in 9.89s[0m
[0m2021.03.24 19:22:40 WARN  Build server is not auto-connectable.[0m
[0m2021.03.24 19:22:40 WARN  no build tool detected in workspace '/Users/stan/Dev/cv'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. [0m
[0m2021.03.24 19:22:47 INFO  shutting down Metals[0m
